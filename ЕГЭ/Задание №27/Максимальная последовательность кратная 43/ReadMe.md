# Задание №27 

Дана последовательность из **N** натуральных чисел. Рассматриваются все её непрерывные подпоследовательности, такие что сумма элементов каждой из них кратна _k = **43**_. Найдите среди них _**подпоследовательность с максимальной суммой**_, _**определите её длину**_. Если таких подпоследовательностей найдено несколько, _**в ответе укажите количество элементов самой короткой из них**_.

## Входные данные:

Даны два входных файла (_файл A_ и _файл B_), каждый из которых содержит в первой строке количество чисел _**N (1 ≤ N ≤ 10 000 000)**_. Каждая из следующих **N** строк содержит одно натуральное число, не превышающее _**10 000**_.

### Пример организации исходных данных во входном файле:

|   |
|---|
| 7 |
| 1 |
| 3 |
| 4 |
| 93 |
| 8 |
| 5 |
| 95 |

### В ответе укажите два числа:

сначала значение искомой суммы для файла **А**, затем – для файла **B**.

### Предупреждение:

для обработки файла **B** не следует использовать переборный алгоритм, вычисляющий сумму для всех возможных вариантов, поскольку написанная по такому алгоритму программа будет выполняться слишком долго.

## [Решение](./eg27_1.cpp):

Если мы возьмём любую последовательность кратную 43, то остаток от деления суммы до начала последовательности и после её завершения окажется одинаковым.

Таким образом получается, что для каждого остатка от деления суммы на 43 будет лишь одна максимальная последовательность - от первого до последнего появления суммы с таким остатком в данных.

[Задаём переменные](./eg27_1.cpp#L7-L18):

```cpp
    int len; cin >> len;
    int NOIDX = len+1;
    
    long long summ = 0;
    long long max_summ = 0;
    int min_len = 0;
    
    int ost_idx[DEVIDER]; for (int i=0; i<DEVIDER; i++) { ost_idx[i] = NOIDX; }
    long long ost_summ[DEVIDER]; for(int i=0; i<DEVIDER; i++) { ost_summ[i] = 0; }
    
    ost_idx[0] = -1;
    ost_summ[0] = 0;
```


Итак - [мы вычитываем данные и аккумулируем их сумму в переменной](./eg27_1.cpp#L20-L23) (лучше выбрать - long long)

```cpp
    for (int i=0; i<len; i++) {
        int num; cin >> num; // Зачитываем номер
        summ += num; // Вычисляем сумму
        int ost = summ % DEVIDER; // Берём остаток
```

[Если остаток встретился первый раз]((./eg27_1.cpp#L24), то [запоминаем его начало и сумму на начало](./eg27_1.cpp#L25-L26):

```cpp
    if (ost_idx[ost] == NOIDX) {
    		ost_idx[ost] = i;
		    ost_summ[ost] = summ;
    }
```

[Если цепочка достигла текущего максимального значения](./eg27_1.cpp#L27-L30), то [сохраняем минимальную длину цепочки](./eg27_1.cpp#L32):

```cpp
    else if (summ - ost_summ[ost] == max_summ &&
             min_len > i - ost_idx[ost] ) {
        min_len = i - ost_idx[ost];
    }
```

[Если же цепочка превысили максимум](./eg27_1.cpp#L35) - [сохраняем её сумму и длину](./eg27_1.cpp#L36-L37):

```cpp
    else if (summ - ost_summ[ost] > max_summ) {
        max_summ = summ - ost_summ[ost];
        min_len = i - ost_idx[ost];
    }
```

Далее - выводим результат:

```cpp
    cout << min_len << '\n';
    return 0;
```