# Задание 27 №[3822](https://100ballnik.com/%d0%b8%d0%bd%d1%84%d0%be%d1%80%d0%bc%d0%b0%d1%82%d0%b8%d0%ba%d0%b0-11-%d0%ba%d0%bb%d0%b0%d1%81%d1%81-%d0%bf%d1%80%d0%be%d0%b1%d0%bd%d1%8b%d0%b9-%d0%b2%d0%b0%d1%80%d0%b8%d0%b0%d0%bd%d1%82-%e2%84%9620/) (А. Кабанов)

В файле записана последовательность натуральных чисел. Гарантируется, **что все числа различны**.
Рассматриваются **все возможные группы чисел**, состоящие из **любого количества элементов последовательности**.
Необходимо найти **количество таких групп**, для которых **сумма элементов кратна 3**.

### Входные данные:

Даны два входных файла (_[файл A](./27-A.txt)_ и _[файл B](./27-B.txt)_), каждый из которых содержит в первой строке количество чисел N (1 ≤ N ≤ 100000). Каждая из следующих N строк содержит одно натуральное число, не превышающее 10 в 8 степени.

### Пример входного файла:

| |
|-|
|4|
|5|
|7|
|12|
|23|


Для указанных данных можно выбрать следующие группы: _**{12}; {7, 23}; {7, 12, 23}; {5,7}; {5, 7, 12}**_.
Программа должна вывести количество этих групп – _**5**_.

В ответе укажите два числа: сначала искомое значение для [файла А](./27-A.txt), затем для [файла B](./27-B.txt).

## Решение:

Пример сохраним в файле [файл «27-0.txt»](./27-0.txt)

### Перебор:

Для начала исходим из того, что файл А может быть обработан перебором. И попробуем это сделать. Данное решение даст нам источник проверки для более сложного варианта программы, ну и гарантирует быстрое получение ответа на пп. А (так сказать - балл). 

Итак - чисел всего 10. Если мы каждому элементу сопоставим 0 (не используется) или 1 (используется), то получим вектор длины 10 из 0 и 1, т.е. бинарное число размерности 10. Это 2 в 10-й степени значений минус 1 (когда нет элементов, т.е. все нули).

Т.о. [мы делаем цикл по всем возможным вариантам](eg27-0.cpp#L14-L15), рассматривая двоичное значение номера варианта как маску, и на каждом шаге мы создаем накопитель, [пробегаем по всем элементам прочитанного набора значений](eg27-0.cpp#L17) и если для позиции элемента в маске указана 1, то мы [добавляем этот элемент в накопитель](eg27-0.cpp#L18). 

[Если накопленное значение кратно 3, то мы увеличиваем счётчик найденных значений на 1](eg27-0.cpp#L20).

Проверяем, что на данных примера получаем 5 и вычисляем значение для файла А.
 
Итак, мы  получили решение для варианта А. 

### Расчёт на везение:

В данном задании вариант B имеет 30 чисел. Это 2 в 30, т.е. это чуть больше миллиарда значений, а это порядка 15 миллиардов операций сложения плюс миллиард взятия остатка. Теоретически можем успеть за 5-10 минут (вдруг повезет с компьютером - на моём macbook за 4 минуты результат вылетел), но если глянуть внимательно, то в файле 9 значений кратно 3 и 21 не кратно. 2 в 21 это 2 с хвостим миллиона значений и в приближении это 31 млн. сложений и пара млн. взятий остатка - вААще успеваем. В этом случае мы поступаем так:

Вводим два числа: [n - для количества кратных 3-м и m - для остальных](eg27-1.cpp#L8-L9). Далее (по мере чтения массива) [если число не кратно 3, то заносим его в массив и инкрементируем длину массива](eg27-1.cpp#L13), иначе [инкрементируем n](eg27-1.cpp#L14).

Если теперь [применить реализованный ранее перебор только к элементам массива, которые не кратны 3](eg27-1.cpp#L17-L25), [заменив size на m](eg27-1.cpp#L17), то мы получим некое число M, которое даст количество множеств элементов, не кратных 3 но в сумме дающих число кратное 3.

Из набора элементов, кратных 3, мы получим количество вариантов, равное 2 в степени m. Определим его как [N](eg27-1.cpp#L26).

[Итоговое значение](eg27-1.cpp#L27): N (количество вариантов с некратными 3-м числами) + M*N (декартово произведение этих 2-х вариантов) - 1 (пустое множество).

Если нам повезло, то мы можем проверить результат для А и получить результат для B (в данном примере ответ получаем моментально).

### А если не повезло...:

Ну вдруг кол-во нечётных больше 31-32, скажем 50. Это уже не решится за разумное время на технике школы в 1 поток. А если 137 - уже проблема с маской, надо алгоритм менять...
Тогда делаем следующее (применительно уже ко второму решению, где отделили кратные и не кратные 3-м числа).

Создаём массив вариантов получения набора, дающего в сумме остаток 0, 1 или 2.

В этом случае мы знаем, что у нас n элементов кратных 3-м, а следовательно мы знаем [N = 1 << n](eg27-2.cpp#L16) - это количество множеств элементов кратных 3-м, дающих в сумме значение кратное 3-м, включая пустое множество.

В итоге инициализируем массив вариантов получения набора с остатками следующим образом: [long cnt[] = {N, 0, 0};](eg27-2.cpp#L17)
Далее мы смотрим [как будет меняться значение вариантов при добавлении числа, делящегося на 3 с остатком 1](eg27-2.cpp#L22-L24) и
[при добавлении числа, делящегося на 3 с остатком 2](eg27-2.cpp#L26-L28).
Так, если добавить число с остатком 1, то кол-во вариантов для получения суммы с остатком 1 [будет равно](eg27-2.cpp#L23): количество вариантов получения суммы с остатком 0.
[Количество вариантов для получения суммы с остатком 0 будет равно ко-ву вариантов для получения суммы с остатком 2](eg27-2.cpp#L23). Ну и аналогично расписывается [выкладка для получения суммы с остатком 2](eg27-2.cpp#L24), ну и вариант при [получении числа из набора с остатком 2](eg27-2.cpp#L26-28).

Далее [сохраняем в массив cnt найденные новые значения](eg27-2.cpp#L30) для количества множеств для разных остатков.

Не забываем из [cnt[0] вычесть 1 при получении результата](eg27-2.cpp#L32) (мы же не рассматриваем в результате пустое множество)

Написали - проверяем для файла-примера, для файла А и считаем для файла B.

### А вдруг число простое, но не 3, а - скажем - 7 или 17...:

В этом случае переписываем [данный if](eg27-2.cpp#L21-L29) в обобщённом виде.

Суть такова: когда мы берём из множества число b, то если мы считаем для суммы с остатком x, то мы принимаем значение равным сумме с остатком, равным x-b по заданному модулю. Вот только проблема в том, что у нас x-b может стать отрицательным.
Поэтому мы получаем значение в диапазоне 0-2 (для делителя 3) следующим образом: (x+3-b)%3, ну а в общем случае: [(x+OST-b)%OST](eg27-3.cpp#L23).

### А проще...:

Ну, мы выделяли числа кратные 3 для сокражение числа переборов. Теперь нам это не требуется, а по этой причине - [заполним массив полностью](eg27-4.cpp#L9-L13) и будем всё считать исходя из того, что для остатка 0 у нас изначально есть 1 вариант (когда множество пусто): [long cnt[] = {1, 0, 0};](eg27-4.cpp#L14), но не забываем его (пустое множество) удалять в конце из результата.
