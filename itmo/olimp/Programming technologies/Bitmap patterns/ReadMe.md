# Технологии программирования

## 7. Шаблоны битовых матриц

### Вариант «А»

|                         |                   |
|:------------------------|:------------------|
| Имя входного файла	  | стандартный ввод  |
| Имя выходного файла	  | стандартный вывод |
| Ограничение по времени  | 4 секунды         |
| Ограничение по памяти	  | 256 мегабайт      |

Назовем шаблоном битовой матрицы размера **a×b** матрицу размера **a×b**, которая может содержать только значения _«1»_ и _«?»_. При этом знак _«?»_ означает любой символ.

Таким образом, например, шаблону:

|   |   |
|:-:|:-:|
| 1 | ? |
| ? | 1 |

соответствуют четыре битовые матрицы:

|   |   |
|:-:|:-:|
| 1 | 0 |
| 0 | 1 |

|   |   |
|:-:|:-:|
| 1 | 1 |
| 0 | 1 |

|   |   |
|:-:|:-:|
| 1 | 0 |
| 1 | 1 |

|   |   |
|:-:|:-:|
| 1 | 1 |
| 1 | 1 |

Вам даны _**n**_ шаблонов размера  _**a×b**_ и _**m**_ битовых матриц такой же размерности. Необходимо для каждого шаблона определить сколько из данных матриц ему соответствуют.

_**Обратите внимание на ограничения, если просто перебрать попарно матрицы и шаблоны, вы получите превышение ограничения по времени!**_

#### Формат входных данных

В первой строке заданы четыре целых числа _**a**_, _**b**_, _**n**_ и _**m**_ — размерности матриц, число шаблонов и число матриц, соответственно (_**1 ≤a⋅b≤12,1≤n,m≤5⋅104**_).

В следующих _**a⋅n**_ строках заданы шаблоны, каждый состоит из _**a**_ строк по _**b**_ символов. Каждый символ, соответственно, либо _**«1»**_, либо _**«?»**_.

Затем в _**a⋅m**_ строках заданы матрицы, каждая матрица так же состоит из a строк по _**b**_ символов. Каждый символ, соответственно, либо _**«1»**_, либо _**«0»**_.

#### Формат выходных данных

Выведите _**n**_ чисел разделенных пробелом — для каждого шаблона, сколько из данных матриц ему соответствует.

Примеры:

|Стандартный ввод	| Стандартный вывод |
|-----------------|-------------------|
| 2 2 3 4         | 3 1 1             |
| 1?              |                   |
| ?1              |                   |
| 11              |                   |
| 11              |                   |
| ?1              |                   |
| ??              |                   |
| 10              |                   |
| 01              |                   |
| 11              |                   |
| 11              |                   |
| 00              |                   |
| 00              |                   |
| 10              |                   |
| 11              |                   |

|Стандартный ввод	| Стандартный вывод |
|-----------------|-------------------|
| 2 3 1 2         | 2.                |
| ???             |                   |
| ???             |                   |
| 101             |                   |
| 111             |                   |
| 111             |                   |
| 000             |                   |

#### Комментарий

Обратите внимание, что ввод и вывод осуществляется через стандартный ввод и стандартный вывод. В случае отрицательного ответа системы проверки заданий по программированию советуем ознакомиться с «[Рекомендациями по решению задач по программированию](https://olymp.itmo.ru/p/olymp-it-21-22/3114)»

### Варианты решения (первые 2 варианта скопировал у ребёнка)

Таким образом любую матрицу можно представить в виде вектора:

| Матрица	| Вектор                  |
|:-------:|:------------------------|
| 1 ? ? 1 | 1 ? ? 1 1 1 ? 1 ? ? ? 1 |
| 1 1 ? 1 |                         |
| ? ? ? 1 |                         |

Согласно условию у нас проверяется символ **'1'** на совпадение, а на месте **'?'** может стоять любой символ.
Плюс по условию _**a⋅b≤12**_. 
Таким образом можно и шаблон и значение представить в виде побитовой последовательности длиной до 12 символов, что явно влезает даже в 16-разрядное значение. 
Если мы вместо **'?'** поставим **0**, а вместо **1** - искомый символ, то получим маску, которая при побитовом **&** даст результат, полностью совпадающий с маской в случае соответствия значения шаблону.
Т.о. мы имеем набор масок и набор значений, которые можно сравнивать побитно.

#### Базовая часть алгоритма

##### Чтение параметров

На старте приложение должно получить параметры на исполнение:

```cpp
    int a, b, n, m;
    cin >> a >> b >> n >> m;
    int size = a*b;
```

Тут мы будем знать параметры a, b, n и m, описанные в условии, а так же размер шаблона в битах.

##### Чтение маски можно организовать следующим образом:

Задаём искомый символ, второй возможный и шаблонный для маски: 

```cpp
const char HIT = '1';
const char ASK = '?';
const char LOOSE = '0'; 
```

Описываем функцию чтения символа (на период чтения шаблона и матрицы игнорируем все символы, кроме 3-х указанных)

```cpp
char read_char() {
    char ch;
    cin >> ch;
    while(ch != HIT && ch != ASK && ch != LOOSE) cin >> ch;
    return ch;
}
```

Описываем функцию получения бита из прочитанных символов для построения шаблона и матрицы:

```cpp
int read_bit() {
    return read_char() == HIT ? 1 : 0;
}
```

Ну и наконец - читаем маску заданного размера:

```cpp 
int read_mask(int size) {
    int result = 0;
    for (int i=0; i<size; i++) {
        result = (result << 1) + read_bit();
    }
    return result;
}
```

##### Чтение шаблона

```cpp
for (int i=0; i<n; i++) {
    int mask = read_mask(size);
    // сохранение масок
} 
```

##### Чтение матриц

```cpp
for (int i=0; i<m; i++) {
    int mask = read_mask(size);
    // проверка на соответствие шаблона с сохранением итога
}
```

##### Вывод результата 

Для отображение результата необходимо подготовить массив счётчиков соответствий шаблонов по порядку их чтения и отобразить:

```cpp
int* counts = new int[m];
for (int i=0; i<n; i++) counts[i] = 0;
// Здесь заполняем массив данными о попаданиях
for (int i=0; i<n; i++) {
    if (i>0) cout << ' ';
    cout << counts[i];
}
```


#### Вариант «A»: [Перебор всех возможных масок](./bitmap_patterns_7a1.cpp)

Идея заключается в том, что количество уникальных шаблонов не превышает 4096. Таким образом мы вне зависимости от количества шаблонов мы можем сверять матрицы только с _**1 << (a⋅b)**_ кол-вом шаблонов.

Т.о. мы строим связный список шаблонов:

```cpp
struct Mask {
    Mask(int mask, Mask *next) : mask(mask), cnt(0), next(next), nums(nullptr) {};
    int mask;
    int cnt;
    Mask *next;
    List *nums;
};
```

При сравнении матрицы с шаблоном результат будет отражаться на счётчике (поле **cnt** матрицы).

В поле **nums** сохраняется связный список номеров шаблонов:

```cpp
struct List {
    List (int num, List* next) : num(num), next(next) {};
    int num;
    List *next;
};
```

При чтении шаблонов мы заполняем связный список структуры **Mask**, сохраняя его корень в переменной root:

```cpp
Mask* root = nullptr;
...
Mask* *masks = new Mask* [MASKS];
for(int i=0; i<MASKS; i++) masks[i] = nullptr;
for(int i=0; i<n; i++) {
    int mask = get_mask(size);
    if (!masks[mask]) {
		    // Если маска отсутствует в массиве - создаём
        root = new Mask(mask, root);
        masks[mask] = root;
    }
    // Номер шаблона добавляем в список номеров 
    masks[mask]->nums = new List(i, masks[mask]->nums);
}
```

При чтении матриц мы проходим по списку шаблонов и для тех, которым она соответствует инкрементируем счётчик **cnt**:

```cpp
for(int i=0; i<m; i++) {
    int value = get_mask(size);
    for (Mask* mask = root; mask; mask = mask->next) {
        if ( (mask->mask & value) == mask->mask ) {
            mask->cnt++;
        }
    }
}
```

Ну и наконец - делаем финальный обход списка Mask, чтобы сохранить счётчики срабатываний в массив:

```cpp
for (Mask* mask = root; mask != nullptr;  mask = mask->next) {
    for(List* nums = mask->nums; nums; nums = nums -> next) {
        counts[nums->num] = mask->cnt;
    }
}
```

_Видимый недостаток данного метода - мы обходим весь набор уникальных шаблонов, хотя многие можно отсекать и ранее, но его производительности вполне может хватить..._

#### Вариант «B»: [Обход дерева с прерыванием](./bitmap_patterns_7a2.cpp) (Взял из кода ребёнка)

Идея данного метода заключается в том, что все шаблоны разворачиваются в двоичное дерево глубины **size**. При получении шаблона он привязывается к узлам дерева, но не к последнему, а к тому, который соответствует последнему значимому биту маски.
Это позволит сократить количество проверок матриц с хвостовыми нулями, так как не понадобится добираться до листа, чтобы отметить срабатывание короткого шаблона.

Для накопления результатов срабатывания создаём структуру в виде связного списка:

```cpp
struct Bit {
    Bit* bits[2];
    int cnt;
    Num* nums;
};
Bit* create_bit(int size) {
    if (size >=0) {
        Bit* bit = new Bit();
        bit->nums = nullptr;
        bit->cnt = 0;
        bit->bits[0] = create_bit(size-1);
        bit->bits[1] = create_bit(size-1);
        return bit;
    }
    return nullptr;
}
``` 

В поле **nums** сохраняется связный список номеров шаблонов:

```cpp
struct Num {
    Num(int num, Num* next) : num(num), next(next) {};
    int num;
    Num* next;
};
```

Наполнение структуры из шаблонов осуществляется методом:

```cpp
void apply_mask(Bit *bit, int mask, int num) {
    if (bit) {
        if (mask == 0) {
            bit->nums = new Num(num, bit->nums);
        } else {
            apply_mask(bit->bits[mask&1], mask >> 1, num);   
        }
    }
}
...
for (int i=0; i<n; i++) {
    int mask = read_mask(size);
    apply_mask(root, mask, i);
}    
```

Наполнение матрицы и поиск совпадение реализован в методе:

```cpp
void check_masks(Bit* bit, int value) {
    if (bit) {
        bit->cnt++;
        if (value > 0) {
            if (value & 1) check_masks(bit->bits[1], value >> 1);
            check_masks(bit->bits[0], value >> 1);
        }
    }
}
...
for (int i=0; i<m; i++) {
    int mask = read_mask(size);
    check_masks(root, mask);
}
```

Для переноса счётчиков срабатываний шаблонов в массив создана процедура **save_counts**:

```cpp
void save_count(Num* num, int cnt, int* counts) {
    if (num) {
        counts[num->num] = cnt;
        save_count(num->next, cnt, counts);
    }
}

void save_counts(Bit* bit, int* counts) {
    if (bit) {
        save_count(bit->nums, bit->cnt, counts);
        for(int i=0; i<2; i++) {
            save_counts(bit->bits[i], counts);
        }
    }
}
```

_Тут матрица строится на всю величину, хотя в идеале можно заполнять её только при применении шаблона и лишь для тех веток, которые в них присутствуют, но это не скажется на требованиях задачи - мы тут вписываемся по объёму, на производительности это не отразится._

_P.S.> На 16Мб файле c 1млн. Матриц по 10000 шаблонов 3x4 получается увеличение скорости в 2.6-2.8 раза по сравнению с предыдущим вариантом_

#### Вариант «C»: [Для тех, кто не любит структуры...](./bitmap_patterns_7a0.cpp) (Я бы рекомендовал, для экономии времени - легче пишется и отлаживается)

На самом деле можно всё упростить. 

Введём параметры:

```cpp
const int SIZE = a×b;
const int MASKS = 1<<SIZE;
```

т.е. MASKS = 4096 - _максимально допустимое количество шаблонов_.

Давайте заведём несколько структур:

* массив уникальных масок - массив размером **a×b** = **SIZE** ≤ 4096 
* массив соответствия шаблона маске - массив размером **n**
* массив активных масок - массив размером до **a×b** ≤ 4096

```cpp
int active_masks = 0;
int* masks_active = new int[MASKS]; // mask# -> mask
```

```cpp
int* masks_pattern = new int[n]; // [mask#] -> mask
```

```cpp
int* masks_cnt = new int[MASKS]; // [mask] -> cnt
for (int i=0; i<MASKS; i++) masks_cnt[i] = -1;
```
   
_**FYI:**_ Сначала инициализируем счётчик числом -1, чтобы определить момент первого появления маски. Все остальные - дубли.

Далее - зачитываем маски:

```cpp
for (int i=0; i<n; i++) {
    int mask = read_mask(SIZE);
    masks_pattern[i] = mask;
```

Если маска появилась первый раз (т.е. Счётчик по ней == -1), то мы устанавливаем счётчик в 0, а саму маску заносим в конец массива активных масок при этом сдвигая счётчик на 1.

```cpp
    if (masks_cnt[mask]) { // Если маска ещё не встречалась
        masks_cnt[mask] = 0; // Ставим счётчик в 0
        masks_active[active_masks++] = mask; // Добавляем активную маску
    }
}
```

Далее для каждой зачитываемой матрицы мы пробегаемся по массиву **«активных»** и если определили соответствие, то в массиве счётчиков инкрементируем значение счётчика по индексу, совпадающему с маской.

```cpp
for (int i=0; i<m; i++) {
    int value = read_mask(SIZE);
    for(int j=0; j<active_masks; j++) {
        int mask = masks_active[j];
        if ( (mask & value) == mask) {
            masks_cnt[mask]++;
        }
    }
}
```

Далее просто отображаем накопленные счётчики. Мы делаем цикл по всем шаблонам. По id шаблона выбираем маску, соответствующему ему, а по маске - количество соответствий матрицы шаблону.

```cpp
for(int i=0; i<n; i++) {
    if(i>0) cout << ' ';
    cout << masks_cnt[masks_pattern[i]];
}
```

В данном случае нам потребуется память в объёме _**sizeof(int) * (n + 2*(1<<(a×b)))**_. Т.е.: для каждой уникальной маски счётчик и сама маска, а для каждого уникального шаблона - сам шаблон, который используется для доступа к счётчику.
